# LRU-K Replacement Policy 实现思路

## 背景概述

LRU-K 算法是一种页面替换策略，用于决定将内存中的哪些页面移回磁盘，以便腾出空间。其核心思想是根据页面的 **Backward K-Distance**（第 K 次访问的时间间隔）来选择淘汰的页面。

本题需要实现一个 `LRUKReplacer` 类，其主要负责跟踪缓冲池中页面的使用情况，并按照以下规则确定页面替换的优先级：

1. 计算每个页面的 **Backward K-Distance**，选择 `k` 距离最大的页面进行淘汰。
2. 如果多个页面的 `k` 距离为无穷大，则选择最早访问的页面淘汰。

---

## 方法功能分解

1. **Evict()**
    - 从所有可淘汰的页面中，选择 `k` 距离最大的页面并返回其 `frame_id`。
    - 如果没有可淘汰的页面，返回 `std::nullopt`。

2. **RecordAccess(frame_id)**
    - 记录页面的访问时间。
    - 维护一个全局递增的时间戳，记录页面最近的 `k` 次访问时间。

3. **SetEvictable(frame_id, bool set_evictable)**
    - 设置页面是否可以被淘汰，并更新可淘汰页面的计数。

4. **Remove(frame_id)**
    - 清除指定页面的访问记录。
    - 如果页面是可淘汰的，减少计数。

5. **Size()**
    - 返回当前可淘汰页面的数量。

---

## 数据结构设计

1. **访问历史**
    - 使用 `std::unordered_map<frame_id_t, std::queue<size_t>>` 存储页面的访问时间戳队列。

2. **可淘汰状态**
    - 使用 `std::unordered_map<frame_id_t, bool>` 记录每个页面是否可被淘汰。

3. **其他辅助变量**
    - `current_timestamp_`：全局时间戳，递增。
    - `size_`：当前可淘汰页面的数量。

---

## 算法核心逻辑

### 1. **Evict()**
- 遍历所有页面，计算每个页面的 `k` 距离。
- 选择 `k` 距离最大或访问时间最早的页面。

### 2. **RecordAccess()**
- 在页面的访问队列中记录当前时间戳。
- 如果队列长度超过 `k`，移除最早的时间戳。

### 3. **SetEvictable()**
- 修改页面的可淘汰状态，并动态更新计数。

### 4. **Remove()**
- 删除页面的访问记录和可淘汰状态。

---

## 多线程支持

- 使用 `std::mutex` 来保护所有共享数据。
- 每个方法调用时加锁，确保线程安全。

---

## 边界条件

1. 页面 `frame_id` 超出范围。
2. 没有任何页面可以淘汰。
3. 页面访问记录不足 `k` 次。
